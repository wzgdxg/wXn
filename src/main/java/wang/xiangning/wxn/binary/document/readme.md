1. 原码  
   原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:  
   [+1]原 = 0000 0001  
   [-1]原 = 1000 0001
   第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:  
   [1111 1111 , 0111 1111]  
   即  
   [-127 , 127]  
   原码是人脑最容易理解和计算的表示方式.
2. 反码  
   反码的表示方法是:  
   正数的反码是其本身   
   负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.  
   [+1] = [00000001]原 = [00000001]反  
   [-1] = [10000001]原 = [11111110]反  
   可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.
3. 补码  
   补码的表示方法是:
   正数的补码就是其本身  
   负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)  
   [+1] = [00000001]原 = [00000001]反 = [00000001]补
   [-1] = [10000001]原 = [11111110]反 = [11111111]补  
   对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.  

   * 一个负整数（或原码）与其补数（或补码）相加，和为模。
     以-11举例  
     -11 原码为 10001011  
     -11 补码为 11110101  
     相加为10000000（高位溢出）=128，这个128即为8位定点数的模  
   
   * 对一个整数的补码再求补码，等于该整数自身。
     这个也是补码的优势之一，原码和补码的转换，可以使用同一套规则，我们以一个负数为例
     -11的原码为10001011
     通过补码的规则转为之后为11110101，此为-11的补码
     该补码再通过相同的规则转换为（11110101的反码加1），10001011  
   
   * 补码的正零与负零表示方法相同。  
     在原码里面，+0和-0的表示方式不同，运算和表达的时候需要增加一些额外的逻辑，在补码里面则没有这个烦恼，补码的+0和-0的表示方式均为00000000（以8位为例） 
   
   * 补码的计算的时候，符号位可以加入运算  
     这也是补码的优势之一，这样可以简化电路逻辑，我们这里面举个简单的例子  
     11+（-2）  
     11的补码为00001011  
     -2的补码为11111110  
     直接相加加过为00001001=9  
   


* 任何一个数 & 1 取出最后一位
  * 1 & 1 = 1  2 & 1 = 0

* 任何一个数 ^ -1 取反

* 整数循环  Integer.MAX_VALUE + 1 = Integer.MIN_VALUE 

* 整数最小值 的补码还是其本身

* Integer.parseInt("-1111111111111111111111111111101", 2); 一定要用“-”

* Integer.parseInt() 不认识补码，所以要传正整数原码，如要表是负数，可以是负数的整数部分前面加-
  * Integer.parseUnsignedInt 认识补码，能解析出负数。